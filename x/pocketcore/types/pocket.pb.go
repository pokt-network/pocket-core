// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: x/pocketcore/pocket.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_pokt_network_pocket_core_types "github.com/pokt-network/pocket-core/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SessionHeader defines the header for session information
type SessionHeader struct {
	ApplicationPubKey  string `protobuf:"bytes,1,opt,name=applicationPubKey,proto3" json:"app_public_key"`
	Chain              string `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain"`
	SessionBlockHeight int64  `protobuf:"varint,3,opt,name=sessionBlockHeight,proto3" json:"session_height"`
}

func (m *SessionHeader) Reset()         { *m = SessionHeader{} }
func (m *SessionHeader) String() string { return proto.CompactTextString(m) }
func (*SessionHeader) ProtoMessage()    {}
func (*SessionHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{0}
}
func (m *SessionHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionHeader.Merge(m, src)
}
func (m *SessionHeader) XXX_Size() int {
	return m.Size()
}
func (m *SessionHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SessionHeader proto.InternalMessageInfo

type Session struct {
	SessionHeader SessionHeader `protobuf:"bytes,1,opt,name=sessionHeader,proto3" json:"header"`
	SessionKey    SessionKey    `protobuf:"bytes,2,opt,name=sessionKey,proto3,casttype=SessionKey" json:"key"`
	SessionNodes  SessionNodes  `protobuf:"bytes,3,rep,name=sessionNodes,proto3,castrepeated=SessionNodes" json:"nodes"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{1}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

type MsgClaim struct {
	SessionHeader    SessionHeader                                     `protobuf:"bytes,1,opt,name=sessionHeader,proto3" json:"header"`
	MerkleRoot       HashRange                                         `protobuf:"bytes,2,opt,name=merkleRoot,proto3" json:"merkle_root"`
	TotalProofs      int64                                             `protobuf:"varint,3,opt,name=totalProofs,proto3" json:"total_proofs"`
	FromAddress      github_com_pokt_network_pocket_core_types.Address `protobuf:"bytes,4,opt,name=fromAddress,proto3,casttype=github.com/pokt-network/pocket-core/types.Address" json:"from_address"`
	EvidenceType     EvidenceType                                      `protobuf:"varint,5,opt,name=evidenceType,proto3,casttype=EvidenceType" json:"evidence_type"`
	ExpirationHeight int64                                             `protobuf:"varint,6,opt,name=expirationHeight,proto3" json:"expiration_height"`
}

func (m *MsgClaim) Reset()         { *m = MsgClaim{} }
func (m *MsgClaim) String() string { return proto.CompactTextString(m) }
func (*MsgClaim) ProtoMessage()    {}
func (*MsgClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{2}
}
func (m *MsgClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaim.Merge(m, src)
}
func (m *MsgClaim) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaim.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaim proto.InternalMessageInfo

func (*MsgClaim) XXX_MessageName() string {
	return "x.pocketcore.MsgClaim"
}

type MsgProtoProof struct {
	MerkleProof  MerkleProof  `protobuf:"bytes,1,opt,name=merkleProof,proto3" json:"merkle_proofs"`
	Leaf         ProofI       `protobuf:"bytes,2,opt,name=leaf,proto3" json:"leaf"`
	EvidenceType EvidenceType `protobuf:"varint,3,opt,name=evidenceType,proto3,casttype=EvidenceType" json:"evidence_type"`
}

func (m *MsgProtoProof) Reset()         { *m = MsgProtoProof{} }
func (m *MsgProtoProof) String() string { return proto.CompactTextString(m) }
func (*MsgProtoProof) ProtoMessage()    {}
func (*MsgProtoProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{3}
}
func (m *MsgProtoProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProtoProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProtoProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProtoProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProtoProof.Merge(m, src)
}
func (m *MsgProtoProof) XXX_Size() int {
	return m.Size()
}
func (m *MsgProtoProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProtoProof.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProtoProof proto.InternalMessageInfo

func (*MsgProtoProof) XXX_MessageName() string {
	return "x.pocketcore.MsgProtoProof"
}

type ProofI struct {
	// Types that are valid to be assigned to Proof:
	//	*ProofI_RelayProof
	//	*ProofI_ChallengeProof
	Proof isProofI_Proof `protobuf_oneof:"proof"`
}

func (m *ProofI) Reset()         { *m = ProofI{} }
func (m *ProofI) String() string { return proto.CompactTextString(m) }
func (*ProofI) ProtoMessage()    {}
func (*ProofI) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{4}
}
func (m *ProofI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofI.Merge(m, src)
}
func (m *ProofI) XXX_Size() int {
	return m.Size()
}
func (m *ProofI) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofI.DiscardUnknown(m)
}

var xxx_messageInfo_ProofI proto.InternalMessageInfo

type isProofI_Proof interface {
	isProofI_Proof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProofI_RelayProof struct {
	RelayProof *RelayProof `protobuf:"bytes,1,opt,name=relayProof,proto3,oneof" json:"relayProof,omitempty"`
}
type ProofI_ChallengeProof struct {
	ChallengeProof *ChallengeProofInvalidData `protobuf:"bytes,2,opt,name=challengeProof,proto3,oneof" json:"challengeProof,omitempty"`
}

func (*ProofI_RelayProof) isProofI_Proof()     {}
func (*ProofI_ChallengeProof) isProofI_Proof() {}

func (m *ProofI) GetProof() isProofI_Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *ProofI) GetRelayProof() *RelayProof {
	if x, ok := m.GetProof().(*ProofI_RelayProof); ok {
		return x.RelayProof
	}
	return nil
}

func (m *ProofI) GetChallengeProof() *ChallengeProofInvalidData {
	if x, ok := m.GetProof().(*ProofI_ChallengeProof); ok {
		return x.ChallengeProof
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProofI) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProofI_RelayProof)(nil),
		(*ProofI_ChallengeProof)(nil),
	}
}

type ProtoEvidence struct {
	BloomBytes    []byte         `protobuf:"bytes,1,opt,name=bloomBytes,proto3" json:"bloom_bytes"`
	SessionHeader *SessionHeader `protobuf:"bytes,2,opt,name=sessionHeader,proto3" json:"evidence_header"`
	NumOfProofs   int64          `protobuf:"varint,3,opt,name=numOfProofs,proto3" json:"num_of_proofs"`
	Proofs        ProofIs        `protobuf:"bytes,4,rep,name=proofs,proto3,castrepeated=ProofIs" json:"proofs"`
	EvidenceType  EvidenceType   `protobuf:"varint,5,opt,name=evidenceType,proto3,casttype=EvidenceType" json:"evidence_type"`
}

func (m *ProtoEvidence) Reset()         { *m = ProtoEvidence{} }
func (m *ProtoEvidence) String() string { return proto.CompactTextString(m) }
func (*ProtoEvidence) ProtoMessage()    {}
func (*ProtoEvidence) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{5}
}
func (m *ProtoEvidence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoEvidence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoEvidence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoEvidence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoEvidence.Merge(m, src)
}
func (m *ProtoEvidence) XXX_Size() int {
	return m.Size()
}
func (m *ProtoEvidence) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoEvidence.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoEvidence proto.InternalMessageInfo

type RelayProof struct {
	RequestHash        string `protobuf:"bytes,1,opt,name=requestHash,proto3" json:"request_hash"`
	Entropy            int64  `protobuf:"varint,2,opt,name=entropy,proto3" json:"entropy"`
	SessionBlockHeight int64  `protobuf:"varint,3,opt,name=sessionBlockHeight,proto3" json:"session_block_height"`
	ServicerPubKey     string `protobuf:"bytes,4,opt,name=servicerPubKey,proto3" json:"servicer_pub_key"`
	Blockchain         string `protobuf:"bytes,5,opt,name=blockchain,proto3" json:"blockchain"`
	Token              AAT    `protobuf:"bytes,6,opt,name=token,proto3" json:"aat"`
	Signature          string `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature"`
}

func (m *RelayProof) Reset()         { *m = RelayProof{} }
func (m *RelayProof) String() string { return proto.CompactTextString(m) }
func (*RelayProof) ProtoMessage()    {}
func (*RelayProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{6}
}
func (m *RelayProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayProof.Merge(m, src)
}
func (m *RelayProof) XXX_Size() int {
	return m.Size()
}
func (m *RelayProof) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayProof.DiscardUnknown(m)
}

var xxx_messageInfo_RelayProof proto.InternalMessageInfo

type ChallengeProofInvalidData struct {
	MajorityResponses []RelayResponse                                   `protobuf:"bytes,1,rep,name=majorityResponses,proto3" json:"majority_responses"`
	MinorityResponse  RelayResponse                                     `protobuf:"bytes,2,opt,name=minorityResponse,proto3" json:"minority_response"`
	ReporterAddress   github_com_pokt_network_pocket_core_types.Address `protobuf:"bytes,3,opt,name=reporterAddress,proto3,casttype=github.com/pokt-network/pocket-core/types.Address" json:"reporters_address"`
}

func (m *ChallengeProofInvalidData) Reset()         { *m = ChallengeProofInvalidData{} }
func (m *ChallengeProofInvalidData) String() string { return proto.CompactTextString(m) }
func (*ChallengeProofInvalidData) ProtoMessage()    {}
func (*ChallengeProofInvalidData) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{7}
}
func (m *ChallengeProofInvalidData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeProofInvalidData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeProofInvalidData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeProofInvalidData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeProofInvalidData.Merge(m, src)
}
func (m *ChallengeProofInvalidData) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeProofInvalidData) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeProofInvalidData.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeProofInvalidData proto.InternalMessageInfo

type RelayResponse struct {
	Signature string     `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature"`
	Response  string     `protobuf:"bytes,2,opt,name=response,proto3" json:"payload"`
	Proof     RelayProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof"`
}

func (m *RelayResponse) Reset()         { *m = RelayResponse{} }
func (m *RelayResponse) String() string { return proto.CompactTextString(m) }
func (*RelayResponse) ProtoMessage()    {}
func (*RelayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{8}
}
func (m *RelayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayResponse.Merge(m, src)
}
func (m *RelayResponse) XXX_Size() int {
	return m.Size()
}
func (m *RelayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RelayResponse proto.InternalMessageInfo

type AAT struct {
	Version              string `protobuf:"bytes,1,opt,name=version,proto3" json:"version"`
	ApplicationPublicKey string `protobuf:"bytes,2,opt,name=applicationPublicKey,proto3" json:"app_pub_key"`
	ClientPublicKey      string `protobuf:"bytes,3,opt,name=clientPublicKey,proto3" json:"client_pub_key"`
	ApplicationSignature string `protobuf:"bytes,4,opt,name=applicationSignature,proto3" json:"signature"`
}

func (m *AAT) Reset()         { *m = AAT{} }
func (m *AAT) String() string { return proto.CompactTextString(m) }
func (*AAT) ProtoMessage()    {}
func (*AAT) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{9}
}
func (m *AAT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AAT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AAT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AAT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AAT.Merge(m, src)
}
func (m *AAT) XXX_Size() int {
	return m.Size()
}
func (m *AAT) XXX_DiscardUnknown() {
	xxx_messageInfo_AAT.DiscardUnknown(m)
}

var xxx_messageInfo_AAT proto.InternalMessageInfo

type MerkleProof struct {
	TargetIndex int64       `protobuf:"varint,1,opt,name=TargetIndex,proto3" json:"index"`
	HashRanges  []HashRange `protobuf:"bytes,2,rep,name=hashRanges,proto3" json:"hash_ranges"`
	Target      HashRange   `protobuf:"bytes,3,opt,name=target,proto3" json:"target_range"`
}

func (m *MerkleProof) Reset()         { *m = MerkleProof{} }
func (m *MerkleProof) String() string { return proto.CompactTextString(m) }
func (*MerkleProof) ProtoMessage()    {}
func (*MerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{10}
}
func (m *MerkleProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleProof.Merge(m, src)
}
func (m *MerkleProof) XXX_Size() int {
	return m.Size()
}
func (m *MerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleProof proto.InternalMessageInfo

// Range for merkle sum index tree
type Range struct {
	Lower uint64 `protobuf:"varint,1,opt,name=lower,proto3" json:"lower"`
	Upper uint64 `protobuf:"varint,2,opt,name=upper,proto3" json:"upper"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{11}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

type HashRange struct {
	Hash  []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"merkleHash"`
	Range Range  `protobuf:"bytes,2,opt,name=range,proto3" json:"range"`
}

func (m *HashRange) Reset()         { *m = HashRange{} }
func (m *HashRange) String() string { return proto.CompactTextString(m) }
func (*HashRange) ProtoMessage()    {}
func (*HashRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd7cbfa14fd73888, []int{12}
}
func (m *HashRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashRange.Merge(m, src)
}
func (m *HashRange) XXX_Size() int {
	return m.Size()
}
func (m *HashRange) XXX_DiscardUnknown() {
	xxx_messageInfo_HashRange.DiscardUnknown(m)
}

var xxx_messageInfo_HashRange proto.InternalMessageInfo

func (m *HashRange) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *HashRange) GetRange() Range {
	if m != nil {
		return m.Range
	}
	return Range{}
}

func init() {
	proto.RegisterType((*SessionHeader)(nil), "x.pocketcore.SessionHeader")
	proto.RegisterType((*Session)(nil), "x.pocketcore.Session")
	proto.RegisterType((*MsgClaim)(nil), "x.pocketcore.MsgClaim")
	proto.RegisterType((*MsgProtoProof)(nil), "x.pocketcore.MsgProtoProof")
	proto.RegisterType((*ProofI)(nil), "x.pocketcore.ProofI")
	proto.RegisterType((*ProtoEvidence)(nil), "x.pocketcore.ProtoEvidence")
	proto.RegisterType((*RelayProof)(nil), "x.pocketcore.RelayProof")
	proto.RegisterType((*ChallengeProofInvalidData)(nil), "x.pocketcore.ChallengeProofInvalidData")
	proto.RegisterType((*RelayResponse)(nil), "x.pocketcore.RelayResponse")
	proto.RegisterType((*AAT)(nil), "x.pocketcore.AAT")
	proto.RegisterType((*MerkleProof)(nil), "x.pocketcore.MerkleProof")
	proto.RegisterType((*Range)(nil), "x.pocketcore.Range")
	proto.RegisterType((*HashRange)(nil), "x.pocketcore.HashRange")
}

func init() { proto.RegisterFile("x/pocketcore/pocket.proto", fileDescriptor_fd7cbfa14fd73888) }

var fileDescriptor_fd7cbfa14fd73888 = []byte{
	// 1322 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcd, 0x6e, 0xdb, 0xc6,
	0x13, 0x17, 0x4d, 0xc9, 0x8e, 0x47, 0x94, 0x3f, 0x36, 0x0e, 0xfe, 0x72, 0xfe, 0x80, 0xe9, 0x1a,
	0x28, 0x62, 0x20, 0x88, 0x8c, 0x3a, 0x6d, 0x50, 0x04, 0x09, 0x50, 0x31, 0x35, 0xea, 0xb4, 0x4d,
	0xe3, 0xac, 0x8d, 0x1e, 0x7a, 0x21, 0x28, 0x6a, 0x2d, 0xb1, 0xa2, 0xb8, 0xec, 0x72, 0xe5, 0x58,
	0x6f, 0x90, 0x63, 0x1f, 0xa1, 0xe8, 0xa1, 0x87, 0x3c, 0x43, 0x1f, 0x20, 0xc7, 0x5c, 0x0a, 0xe4,
	0x50, 0x30, 0x85, 0x7d, 0x23, 0xfa, 0x00, 0x45, 0x4e, 0xc5, 0x7e, 0x50, 0x22, 0x6d, 0xc7, 0x29,
	0xfa, 0x71, 0x31, 0x57, 0x33, 0xbf, 0x99, 0x9d, 0xef, 0x59, 0xc3, 0xea, 0xf1, 0x56, 0x4c, 0xfd,
	0x01, 0xe1, 0x3e, 0x65, 0x44, 0x1f, 0x5b, 0x31, 0xa3, 0x9c, 0x22, 0xeb, 0xb8, 0x35, 0x65, 0x5d,
	0x5f, 0xe9, 0xd1, 0x1e, 0x95, 0x8c, 0x2d, 0x71, 0x52, 0x98, 0x8d, 0x9f, 0x0d, 0x68, 0xec, 0x93,
	0x24, 0x09, 0x68, 0xb4, 0x4b, 0xbc, 0x2e, 0x61, 0xe8, 0x13, 0x58, 0xf6, 0xe2, 0x38, 0x0c, 0x7c,
	0x8f, 0x07, 0x34, 0xda, 0x1b, 0x75, 0xbe, 0x20, 0xe3, 0xa6, 0xb1, 0x6e, 0x6c, 0xce, 0x3b, 0x28,
	0x4b, 0xed, 0x05, 0x2f, 0x8e, 0xdd, 0x78, 0xd4, 0x09, 0x03, 0xdf, 0x1d, 0x90, 0x31, 0x3e, 0x0f,
	0x46, 0x36, 0xd4, 0xfc, 0xbe, 0x17, 0x44, 0xcd, 0x19, 0x29, 0x35, 0x9f, 0xa5, 0xb6, 0x22, 0x60,
	0xf5, 0x41, 0x0e, 0xa0, 0x44, 0xdd, 0xe9, 0x84, 0xd4, 0x1f, 0xec, 0x92, 0xa0, 0xd7, 0xe7, 0x4d,
	0x73, 0xdd, 0xd8, 0x34, 0xd5, 0x1d, 0x9a, 0xeb, 0xf6, 0x25, 0x07, 0x5f, 0x80, 0xbe, 0x5b, 0x7d,
	0xf6, 0x83, 0x5d, 0xd9, 0x78, 0x65, 0xc0, 0x9c, 0x36, 0x1f, 0x3d, 0x81, 0x46, 0x52, 0xf4, 0x44,
	0x1a, 0x5d, 0xdf, 0xfe, 0x7f, 0xab, 0x18, 0x86, 0x56, 0xc9, 0x59, 0x67, 0xe1, 0x45, 0x6a, 0x57,
	0xb2, 0xd4, 0x9e, 0xed, 0xcb, 0xdf, 0xb8, 0xac, 0x01, 0x7d, 0x04, 0xa0, 0x09, 0x22, 0x08, 0xc2,
	0x1d, 0xcb, 0xb9, 0x96, 0xa5, 0xb6, 0x39, 0x20, 0xe3, 0x37, 0xa9, 0x0d, 0xfb, 0x13, 0x26, 0x2e,
	0x00, 0xd1, 0x7d, 0xb0, 0xf4, 0xaf, 0xaf, 0x68, 0x97, 0x24, 0x4d, 0x73, 0xdd, 0xdc, 0xb4, 0x9c,
	0x55, 0x11, 0x87, 0x48, 0x10, 0x9e, 0xbf, 0xb6, 0xad, 0xfd, 0x02, 0x00, 0x97, 0xe0, 0xda, 0xb5,
	0x5f, 0x4d, 0xb8, 0xf2, 0x28, 0xe9, 0x3d, 0x08, 0xbd, 0x60, 0xf8, 0x5f, 0xf8, 0xf6, 0x25, 0xc0,
	0x90, 0xb0, 0x41, 0x48, 0x30, 0xa5, 0x5c, 0xfa, 0x56, 0xdf, 0xfe, 0x5f, 0x59, 0xdf, 0xae, 0x97,
	0xf4, 0xb1, 0x17, 0xf5, 0x88, 0x73, 0x55, 0xeb, 0xaa, 0x2b, 0x11, 0x97, 0x51, 0xca, 0x71, 0x41,
	0x1e, 0x6d, 0x43, 0x9d, 0x53, 0xee, 0x85, 0x7b, 0x8c, 0xd2, 0xc3, 0x44, 0xe7, 0x72, 0x29, 0x4b,
	0x6d, 0x4b, 0x92, 0xdd, 0x58, 0xd2, 0x71, 0x11, 0x84, 0x7a, 0x50, 0x3f, 0x64, 0x74, 0xd8, 0xee,
	0x76, 0x19, 0x49, 0x92, 0x66, 0x55, 0x86, 0x77, 0x47, 0xc8, 0x08, 0xb2, 0xeb, 0x29, 0xfa, 0x9b,
	0xd4, 0xfe, 0xa0, 0x17, 0xf0, 0xfe, 0xa8, 0xd3, 0xf2, 0xe9, 0x70, 0x2b, 0xa6, 0x03, 0x7e, 0x2b,
	0x22, 0xfc, 0x29, 0x65, 0x03, 0x5d, 0xee, 0xb7, 0x64, 0xe9, 0xf3, 0x71, 0x4c, 0x92, 0x96, 0x56,
	0x86, 0x8b, 0x9a, 0xd1, 0x0e, 0x58, 0xe4, 0x28, 0xe8, 0x92, 0xc8, 0x27, 0x07, 0xe3, 0x98, 0x34,
	0x6b, 0xeb, 0xc6, 0x66, 0xcd, 0x79, 0x2f, 0x4b, 0xed, 0x46, 0x4e, 0x77, 0x85, 0xf8, 0x9b, 0xd4,
	0xb6, 0x76, 0x0a, 0x40, 0x5c, 0x12, 0x43, 0x6d, 0x58, 0x22, 0xc7, 0x71, 0xc0, 0x64, 0xad, 0xeb,
	0xa2, 0x9d, 0x95, 0x8e, 0x8a, 0x9a, 0x58, 0x9e, 0xf2, 0xf2, 0xba, 0x3d, 0x07, 0xbf, 0x7b, 0x45,
	0xa4, 0xf6, 0xd9, 0x8f, 0xb6, 0xb1, 0xf1, 0xbb, 0x01, 0x8d, 0x47, 0x49, 0x6f, 0x4f, 0x74, 0xa1,
	0x8c, 0x07, 0xc2, 0xa0, 0xa3, 0x2b, 0x7f, 0xea, 0x0c, 0xaf, 0x96, 0x33, 0xf2, 0x68, 0x0a, 0x70,
	0xae, 0xe9, 0x9c, 0x34, 0x74, 0x4e, 0xf2, 0x10, 0x17, 0x94, 0xa0, 0x3b, 0x50, 0x0d, 0x89, 0x77,
	0xa8, 0xd3, 0xbb, 0x52, 0x56, 0x26, 0x21, 0x0f, 0x1d, 0x4b, 0xeb, 0x91, 0x48, 0x2c, 0xff, 0x9e,
	0x8b, 0x98, 0xf9, 0xb7, 0x22, 0x56, 0x70, 0xf7, 0x27, 0x03, 0x66, 0xd5, 0x7d, 0xe8, 0x2e, 0x00,
	0x23, 0xa1, 0x37, 0x2e, 0xba, 0xd9, 0x2c, 0x5b, 0x86, 0x27, 0xfc, 0xdd, 0x0a, 0x2e, 0xa0, 0xd1,
	0x13, 0x58, 0xf0, 0xfb, 0x5e, 0x18, 0x92, 0xa8, 0xa7, 0xc3, 0xa4, 0x3c, 0xbb, 0x51, 0x96, 0x7f,
	0x50, 0xc2, 0x3c, 0x8c, 0x8e, 0xbc, 0x30, 0xe8, 0x7e, 0xea, 0x71, 0x6f, 0xb7, 0x82, 0xcf, 0x28,
	0x50, 0xdd, 0xe6, 0xcc, 0x41, 0x4d, 0xc6, 0x6f, 0xe3, 0x74, 0x06, 0x1a, 0x32, 0x29, 0xb9, 0x5b,
	0x68, 0x0b, 0xa0, 0x13, 0x52, 0x3a, 0x74, 0xc6, 0x9c, 0x24, 0xd2, 0x5e, 0xcb, 0x59, 0x14, 0xbd,
	0x20, 0xa9, 0x6e, 0x47, 0x90, 0x71, 0x01, 0x82, 0xbe, 0x3e, 0xdb, 0xac, 0x33, 0xef, 0x6e, 0xd6,
	0xab, 0x59, 0x6a, 0x2f, 0x4e, 0x42, 0x7b, 0x71, 0xc7, 0xde, 0x86, 0x7a, 0x34, 0x1a, 0x3e, 0x3e,
	0x2c, 0xf5, 0xd8, 0xb2, 0xc8, 0x49, 0x34, 0x1a, 0xba, 0xf4, 0x70, 0x52, 0x01, 0x05, 0x14, 0xfa,
	0x0c, 0x66, 0x15, 0xb9, 0x59, 0x5d, 0x37, 0xdf, 0x5a, 0x03, 0xab, 0xf9, 0xac, 0x50, 0xd8, 0xe7,
	0xaf, 0xed, 0x39, 0xc5, 0x49, 0xb0, 0x26, 0xfd, 0x4b, 0x4d, 0xa4, 0x87, 0xdb, 0x33, 0x13, 0x60,
	0x9a, 0x64, 0x31, 0x3d, 0x18, 0xf9, 0x6e, 0x44, 0x12, 0x2e, 0x46, 0x8e, 0xde, 0x36, 0x72, 0x7a,
	0x68, 0xb2, 0xdb, 0x17, 0xa3, 0xa8, 0x08, 0x42, 0xef, 0xc3, 0x1c, 0x89, 0x38, 0xa3, 0xb1, 0x1a,
	0xcc, 0xa6, 0x53, 0xcf, 0x52, 0x3b, 0x27, 0xe1, 0xfc, 0x80, 0x76, 0x2f, 0xd9, 0x35, 0xcd, 0x2c,
	0xb5, 0x57, 0xf2, 0x5d, 0xd3, 0x11, 0xec, 0x4b, 0x36, 0x0e, 0xba, 0x07, 0x0b, 0x09, 0x61, 0x47,
	0x81, 0x4f, 0x98, 0xde, 0x8a, 0x55, 0x69, 0xe7, 0x4a, 0x96, 0xda, 0x4b, 0x39, 0x47, 0xac, 0x46,
	0xb9, 0x17, 0xcf, 0x60, 0x51, 0x4b, 0x56, 0x91, 0x3f, 0x50, 0x9b, 0xb1, 0x26, 0x25, 0x17, 0xb2,
	0xd4, 0x2e, 0x50, 0x71, 0xe1, 0x8c, 0x3e, 0x84, 0x1a, 0xa7, 0x03, 0x12, 0xc9, 0x09, 0x53, 0xdf,
	0x5e, 0x2e, 0xa7, 0xad, 0xdd, 0x3e, 0x70, 0xea, 0x3a, 0x67, 0xa6, 0xe7, 0x71, 0xac, 0xc0, 0xe8,
	0x26, 0xcc, 0x27, 0x41, 0x2f, 0xf2, 0xf8, 0x88, 0x91, 0xe6, 0x9c, 0xbc, 0xa4, 0x91, 0xa5, 0xf6,
	0x94, 0x88, 0xa7, 0x47, 0x9d, 0x8a, 0x93, 0x19, 0x58, 0x7d, 0x6b, 0xbf, 0x20, 0x02, 0xcb, 0x43,
	0xef, 0x5b, 0xca, 0x02, 0x3e, 0xc6, 0x24, 0x89, 0x69, 0x94, 0xc8, 0x1e, 0x30, 0xcf, 0xd7, 0xb3,
	0x4c, 0x67, 0x8e, 0x71, 0xae, 0x6b, 0xe3, 0x50, 0x2e, 0xed, 0xb2, 0x5c, 0x1c, 0x9f, 0xd7, 0x88,
	0x3a, 0xb0, 0x34, 0x0c, 0xa2, 0x12, 0xf1, 0xe2, 0xae, 0x29, 0xdf, 0x92, 0x97, 0xed, 0x72, 0x2e,
	0x3c, 0xb9, 0x05, 0x9f, 0xd3, 0x87, 0x38, 0x2c, 0x32, 0x12, 0x53, 0xc6, 0x09, 0xcb, 0x57, 0x8e,
	0x29, 0x9b, 0xf9, 0x73, 0xa1, 0x21, 0x67, 0x25, 0xff, 0x6c, 0xef, 0x9c, 0xbd, 0x42, 0x07, 0xf9,
	0xb9, 0x01, 0x8d, 0x92, 0xe9, 0xe5, 0x4c, 0x19, 0x97, 0x67, 0x0a, 0xdd, 0x80, 0x2b, 0xac, 0x18,
	0x96, 0x79, 0x55, 0xec, 0xb1, 0x37, 0x0e, 0xa9, 0xd7, 0xc5, 0x13, 0x26, 0xba, 0xaf, 0xc7, 0x98,
	0xf4, 0xec, 0x92, 0xb1, 0xea, 0x34, 0x74, 0xe4, 0x14, 0x1c, 0xab, 0x8f, 0x36, 0xf6, 0x0f, 0x03,
	0xcc, 0x76, 0xfb, 0x40, 0x74, 0xd8, 0x11, 0x61, 0xa2, 0x0d, 0xb4, 0x81, 0xf2, 0x52, 0x4d, 0xc2,
	0xf9, 0x01, 0x3d, 0x80, 0x95, 0xf2, 0x1b, 0x30, 0x0c, 0xfc, 0xfc, 0xb9, 0x34, 0xaf, 0x26, 0xa5,
	0x7e, 0x33, 0xca, 0xc6, 0xb8, 0x10, 0x8c, 0xee, 0xc1, 0xa2, 0x1f, 0x06, 0x24, 0xe2, 0x53, 0x79,
	0x73, 0xfa, 0xe6, 0x54, 0xac, 0x89, 0x8a, 0xb3, 0x50, 0xd4, 0x2e, 0x99, 0xb0, 0x3f, 0x89, 0x6b,
	0xf5, 0xa2, 0xb8, 0x5e, 0x08, 0xd5, 0xae, 0xff, 0x62, 0x40, 0xbd, 0xb0, 0x63, 0xd1, 0x4d, 0xa8,
	0x1f, 0x78, 0xac, 0x47, 0xf8, 0xc3, 0xa8, 0x4b, 0x8e, 0x65, 0x18, 0x4c, 0xf5, 0xa0, 0x0d, 0x04,
	0x01, 0x17, 0xb9, 0xe2, 0x45, 0xd5, 0xcf, 0x5f, 0x4c, 0x49, 0x73, 0x46, 0x36, 0xc9, 0xbb, 0x5f,
	0x54, 0x42, 0xc4, 0x65, 0x52, 0x06, 0x17, 0xe4, 0xd1, 0x0e, 0xcc, 0x72, 0xa9, 0x5c, 0xe7, 0xf2,
	0xad, 0x9a, 0x56, 0xb4, 0x26, 0x4b, 0xc1, 0x95, 0x2e, 0xac, 0x85, 0xb5, 0x5f, 0x8f, 0xa1, 0x26,
	0xc1, 0xe2, 0x6d, 0x1e, 0xd2, 0xa7, 0xfa, 0x01, 0x59, 0x55, 0xae, 0x48, 0x02, 0x56, 0x1f, 0x01,
	0x18, 0xc5, 0xb1, 0x5e, 0x5a, 0x1a, 0x20, 0x09, 0x58, 0x7d, 0xb4, 0xc2, 0x00, 0xe6, 0x27, 0x16,
	0xa0, 0x0d, 0xa8, 0xf6, 0xf3, 0xb9, 0x6d, 0xa9, 0xa9, 0xa6, 0x1e, 0x21, 0x12, 0x22, 0x79, 0xe8,
	0x63, 0xa8, 0x49, 0xc3, 0x74, 0x5b, 0x5f, 0x3d, 0x53, 0x99, 0xd2, 0x93, 0x49, 0x51, 0x2a, 0x17,
	0xd4, 0xc7, 0xd9, 0x7b, 0x71, 0xb2, 0x66, 0xbc, 0x3c, 0x59, 0x33, 0x7e, 0x3b, 0x59, 0x33, 0xbe,
	0x3f, 0x5d, 0xab, 0xbc, 0x3c, 0x5d, 0xab, 0xbc, 0x3a, 0x5d, 0xab, 0x7c, 0x73, 0xe7, 0xaf, 0xf4,
	0x67, 0xe9, 0xff, 0x23, 0xd9, 0xac, 0x9d, 0x59, 0xf9, 0xbf, 0xcf, 0xed, 0x3f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0xa5, 0xfb, 0x71, 0x3c, 0x3c, 0x0d, 0x00, 0x00,
}

func (m *SessionHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionBlockHeight != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.SessionBlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApplicationPubKey) > 0 {
		i -= len(m.ApplicationPubKey)
		copy(dAtA[i:], m.ApplicationPubKey)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.ApplicationPubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SessionNodes) > 0 {
		for iNdEx := len(m.SessionNodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SessionNodes[iNdEx])
			copy(dAtA[i:], m.SessionNodes[iNdEx])
			i = encodeVarintPocket(dAtA, i, uint64(len(m.SessionNodes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SessionKey) > 0 {
		i -= len(m.SessionKey)
		copy(dAtA[i:], m.SessionKey)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.SessionKey)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.SessionHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpirationHeight != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.ExpirationHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.EvidenceType != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.EvidenceType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.TotalProofs != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.TotalProofs))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.MerkleRoot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.SessionHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgProtoProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProtoProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProtoProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EvidenceType != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.EvidenceType))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Leaf.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.MerkleProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProofI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size := m.Proof.Size()
			i -= size
			if _, err := m.Proof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProofI_RelayProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofI_RelayProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RelayProof != nil {
		{
			size, err := m.RelayProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPocket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ProofI_ChallengeProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofI_ChallengeProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ChallengeProof != nil {
		{
			size, err := m.ChallengeProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPocket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ProtoEvidence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoEvidence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoEvidence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EvidenceType != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.EvidenceType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Proofs) > 0 {
		for iNdEx := len(m.Proofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Proofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPocket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumOfProofs != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.NumOfProofs))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionHeader != nil {
		{
			size, err := m.SessionHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPocket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.BloomBytes) > 0 {
		i -= len(m.BloomBytes)
		copy(dAtA[i:], m.BloomBytes)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.BloomBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RelayProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Blockchain) > 0 {
		i -= len(m.Blockchain)
		copy(dAtA[i:], m.Blockchain)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.Blockchain)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServicerPubKey) > 0 {
		i -= len(m.ServicerPubKey)
		copy(dAtA[i:], m.ServicerPubKey)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.ServicerPubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.SessionBlockHeight != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.SessionBlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.Entropy != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.Entropy))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RequestHash) > 0 {
		i -= len(m.RequestHash)
		copy(dAtA[i:], m.RequestHash)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.RequestHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeProofInvalidData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeProofInvalidData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeProofInvalidData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReporterAddress) > 0 {
		i -= len(m.ReporterAddress)
		copy(dAtA[i:], m.ReporterAddress)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.ReporterAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.MinorityResponse.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MajorityResponses) > 0 {
		for iNdEx := len(m.MajorityResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MajorityResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPocket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RelayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Response) > 0 {
		i -= len(m.Response)
		copy(dAtA[i:], m.Response)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.Response)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AAT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AAT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AAT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApplicationSignature) > 0 {
		i -= len(m.ApplicationSignature)
		copy(dAtA[i:], m.ApplicationSignature)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.ApplicationSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClientPublicKey) > 0 {
		i -= len(m.ClientPublicKey)
		copy(dAtA[i:], m.ClientPublicKey)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.ClientPublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ApplicationPublicKey) > 0 {
		i -= len(m.ApplicationPublicKey)
		copy(dAtA[i:], m.ApplicationPublicKey)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.ApplicationPublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MerkleProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.HashRanges) > 0 {
		for iNdEx := len(m.HashRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HashRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPocket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TargetIndex != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.TargetIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Upper != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.Upper))
		i--
		dAtA[i] = 0x10
	}
	if m.Lower != 0 {
		i = encodeVarintPocket(dAtA, i, uint64(m.Lower))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HashRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPocket(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPocket(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPocket(dAtA []byte, offset int, v uint64) int {
	offset -= sovPocket(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SessionHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApplicationPubKey)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	if m.SessionBlockHeight != 0 {
		n += 1 + sovPocket(uint64(m.SessionBlockHeight))
	}
	return n
}

func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SessionHeader.Size()
	n += 1 + l + sovPocket(uint64(l))
	l = len(m.SessionKey)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	if len(m.SessionNodes) > 0 {
		for _, b := range m.SessionNodes {
			l = len(b)
			n += 1 + l + sovPocket(uint64(l))
		}
	}
	return n
}

func (m *MsgClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SessionHeader.Size()
	n += 1 + l + sovPocket(uint64(l))
	l = m.MerkleRoot.Size()
	n += 1 + l + sovPocket(uint64(l))
	if m.TotalProofs != 0 {
		n += 1 + sovPocket(uint64(m.TotalProofs))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	if m.EvidenceType != 0 {
		n += 1 + sovPocket(uint64(m.EvidenceType))
	}
	if m.ExpirationHeight != 0 {
		n += 1 + sovPocket(uint64(m.ExpirationHeight))
	}
	return n
}

func (m *MsgProtoProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MerkleProof.Size()
	n += 1 + l + sovPocket(uint64(l))
	l = m.Leaf.Size()
	n += 1 + l + sovPocket(uint64(l))
	if m.EvidenceType != 0 {
		n += 1 + sovPocket(uint64(m.EvidenceType))
	}
	return n
}

func (m *ProofI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proof != nil {
		n += m.Proof.Size()
	}
	return n
}

func (m *ProofI_RelayProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelayProof != nil {
		l = m.RelayProof.Size()
		n += 1 + l + sovPocket(uint64(l))
	}
	return n
}
func (m *ProofI_ChallengeProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChallengeProof != nil {
		l = m.ChallengeProof.Size()
		n += 1 + l + sovPocket(uint64(l))
	}
	return n
}
func (m *ProtoEvidence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BloomBytes)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	if m.SessionHeader != nil {
		l = m.SessionHeader.Size()
		n += 1 + l + sovPocket(uint64(l))
	}
	if m.NumOfProofs != 0 {
		n += 1 + sovPocket(uint64(m.NumOfProofs))
	}
	if len(m.Proofs) > 0 {
		for _, e := range m.Proofs {
			l = e.Size()
			n += 1 + l + sovPocket(uint64(l))
		}
	}
	if m.EvidenceType != 0 {
		n += 1 + sovPocket(uint64(m.EvidenceType))
	}
	return n
}

func (m *RelayProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestHash)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	if m.Entropy != 0 {
		n += 1 + sovPocket(uint64(m.Entropy))
	}
	if m.SessionBlockHeight != 0 {
		n += 1 + sovPocket(uint64(m.SessionBlockHeight))
	}
	l = len(m.ServicerPubKey)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	l = len(m.Blockchain)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	l = m.Token.Size()
	n += 1 + l + sovPocket(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	return n
}

func (m *ChallengeProofInvalidData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MajorityResponses) > 0 {
		for _, e := range m.MajorityResponses {
			l = e.Size()
			n += 1 + l + sovPocket(uint64(l))
		}
	}
	l = m.MinorityResponse.Size()
	n += 1 + l + sovPocket(uint64(l))
	l = len(m.ReporterAddress)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	return n
}

func (m *RelayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	l = len(m.Response)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	l = m.Proof.Size()
	n += 1 + l + sovPocket(uint64(l))
	return n
}

func (m *AAT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	l = len(m.ApplicationPublicKey)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	l = len(m.ClientPublicKey)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	l = len(m.ApplicationSignature)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	return n
}

func (m *MerkleProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetIndex != 0 {
		n += 1 + sovPocket(uint64(m.TargetIndex))
	}
	if len(m.HashRanges) > 0 {
		for _, e := range m.HashRanges {
			l = e.Size()
			n += 1 + l + sovPocket(uint64(l))
		}
	}
	l = m.Target.Size()
	n += 1 + l + sovPocket(uint64(l))
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lower != 0 {
		n += 1 + sovPocket(uint64(m.Lower))
	}
	if m.Upper != 0 {
		n += 1 + sovPocket(uint64(m.Upper))
	}
	return n
}

func (m *HashRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPocket(uint64(l))
	}
	l = m.Range.Size()
	n += 1 + l + sovPocket(uint64(l))
	return n
}

func sovPocket(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPocket(x uint64) (n int) {
	return sovPocket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SessionHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionBlockHeight", wireType)
			}
			m.SessionBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionKey = append(m.SessionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionKey == nil {
				m.SessionKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionNodes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionNodes = append(m.SessionNodes, make([]byte, postIndex-iNdEx))
			copy(m.SessionNodes[len(m.SessionNodes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MerkleRoot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalProofs", wireType)
			}
			m.TotalProofs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalProofs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = append(m.FromAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.FromAddress == nil {
				m.FromAddress = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceType", wireType)
			}
			m.EvidenceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvidenceType |= EvidenceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationHeight", wireType)
			}
			m.ExpirationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProtoProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProtoProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProtoProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MerkleProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Leaf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceType", wireType)
			}
			m.EvidenceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvidenceType |= EvidenceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RelayProof{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Proof = &ProofI_RelayProof{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChallengeProofInvalidData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Proof = &ProofI_ChallengeProof{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoEvidence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoEvidence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoEvidence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BloomBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BloomBytes = append(m.BloomBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.BloomBytes == nil {
				m.BloomBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionHeader == nil {
				m.SessionHeader = &SessionHeader{}
			}
			if err := m.SessionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfProofs", wireType)
			}
			m.NumOfProofs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfProofs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proofs = append(m.Proofs, ProofI{})
			if err := m.Proofs[len(m.Proofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceType", wireType)
			}
			m.EvidenceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvidenceType |= EvidenceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelayProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entropy", wireType)
			}
			m.Entropy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Entropy |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionBlockHeight", wireType)
			}
			m.SessionBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicerPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicerPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blockchain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blockchain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeProofInvalidData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeProofInvalidData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeProofInvalidData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorityResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MajorityResponses = append(m.MajorityResponses, RelayResponse{})
			if err := m.MajorityResponses[len(m.MajorityResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorityResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinorityResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReporterAddress = append(m.ReporterAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ReporterAddress == nil {
				m.ReporterAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AAT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AAT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AAT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIndex", wireType)
			}
			m.TargetIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashRanges = append(m.HashRanges, HashRange{})
			if err := m.HashRanges[len(m.HashRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPocket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPocket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPocket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPocket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPocket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPocket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPocket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPocket
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPocket
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPocket
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPocket        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPocket          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPocket = fmt.Errorf("proto: unexpected end of group")
)
